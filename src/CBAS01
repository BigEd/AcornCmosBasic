;                        FILE 1      declarations and startup > CBAS01
 ORG &8000
 CPU 1 ; this version solely for CMOS 6502

REPPTR * &00FD
LOMEM * &0000
FSA * LOMEM+2
AESTKP * FSA+2
HIMEM * AESTKP+2
LOLINO * HIMEM+2
CURSOR * LOLINO+2
LINE * CURSOR+1
SEED * LINE+2
TOP * SEED+5
PRINTS * TOP+2
PRINTF * PRINTS+1
OSCLI * &FFF7
OSWRCH * &FFEE
OSASCI * &FFE3
OSCRLF * &FFE7
OSRDCH * &FFE0
OSFILE * &FFDD
OSARGS * &FFDA
OSBGET * &FFD7
OSBPUT * OSBGET-3
OSFIND * OSBPUT-6
OSBYTE * &FFF4
OSWORD * &FFF1
ERRORH * PRINTF+1
TXTP * ERRORH+2
AELINE * TXTP+1
AECUR * AELINE+2
DATAP * AECUR+1
TALLY * DATAP+2
LISTOP * TALLY+1
TRFLAG * LISTOP+1
TRNUM * TRFLAG+1
WIDTHV * TRNUM+2
DOSTKP * WIDTHV+1
SUBSTP * DOSTKP+1
FORSTP * SUBSTP+1
TYPE * FORSTP+1
BYTESM * TYPE+1
OPCODE * BYTESM+1
IACCL * OPCODE+1
IACCM * IACCL+1
IACCN * IACCL+2
IACCH * IACCL+3
FACCS * IACCL+4
FACCXH * FACCS+1
FACCX * FACCXH+1
FACCMA * FACCX+1
FACCMB * FACCMA+1
FACCMC * FACCMB+1
FACCMD * FACCMC+1
FACCMG * FACCMD+1
CLEN * FACCMG+1
WORK * CLEN+1
MODE * WORK+4
CONSTA * MODE+1
FWRKS * WORK+4
FWRKX * FWRKS+1
FWRKMA * FWRKX+1
FWRKMB * FWRKMA+1
FWRKMC * FWRKMB+1
FWRKMD * FWRKMC+1
FWRKMG * FWRKMD+1
FTMPMA * FWRKMG+1
FTMPMB * FTMPMA+1
FTMPMC * FTMPMB+1
FTMPMD * FTMPMC+1
FTMPMG * FTMPMD+1
FRDDDP * FTMPMG+1
FRDDDX * FRDDDP+1
FPRTDX * FRDDDX
FRDDW * FRDDDX+1
FQUAD * FRDDW
ARGP * FQUAD+1
FPRTWY * ARGP+2
FPRTWN * FPRTWY+1
FDIGS * FPRTWN
COEFP * ARGP+2
NEWVAR * COEFP+2
VARL * &0400
PC * VARL+&40
FWSA * VARL+&6C
FWSB * FWSA+5
FWSC * FWSB+5
FWSD * FWSC+5
VARPTR * &0480
DOADL * &0500
DOADH * DOADL+&14
FORINL * DOADH+&14
FORINH * FORINL+1
FORINT * FORINH+1
FORSPL * FORINT+1
FORSPM * FORSPL+1
FORSPN * FORSPM+1
FORSPH * FORSPN+1
FORSPE * FORSPH+1
FORLML * FORSPE+1
FORLMM * FORLML+1
FORLMN * FORLMM+1
FORLMH * FORLMN+1
FORLME * FORLMH+1
FORADL * FORLME+1
FORADH * FORADL+1
SUBADL * FORADH+&96
SUBADH * SUBADL+&1A
STRACC * &0600
BUFFER * &0700
FORTOP * &96
SUBTOP * &1A
DOTOP * &14
BB CMPIM 1
 BEQ ENTRY
 RTS
 NOP
 = &60 ;defn
 = COPYR
 = &04 ;ver
 = "BASIC"

COPYR = 0
 = "(C)1984 Acorn",10,13
 = 0
 & BB
VALM = &00
 = &00;next two zeroes!
 = &00
 = &03
 = &27
VALL = &01 ;table of numeric values
 = &0A
 = &64
 = &E8
 = &10
ENTRY AND SEED+4 ;A was 1 so test bottom bit
 ORA SEED
 ORA SEED+1
 ORA SEED+2
 ORA SEED+3
 BNE RNDOK
 LDAIM "A"
 STA SEED
 EORIM "R" :EOR: "A"
 STA SEED+1
 EORIM "W" :EOR: "R"
 STA SEED+2
RNDOK LDAIM &84
 JSR OSBYTE
 STX HIMEM
 STY HIMEM+1
 DEA ;A=&83 now
 JSR OSBYTE
 STY TXTP
 CLR LISTOP
 CLR VARL+2
 CLR VARL+3
 LDXIM &FF
 STX WIDTHV
 LDXIM 10
 STX VARL
 DEX
 STX VARL+1
 LDAIM BREK
 STA &202
 LDAIM /BREK
 STA &203
 CLI
 JMP ENTRYY
LOOKFN STY WORK+2
 LDYIM 1
 LDAIY WORK
 LDYIM &F6
 CMPIM TPROC
 BEQ LOOKMN
 LDYIM &F8
 BRA LOOKMN
;  LOOKUP is given a base address-1 in WORK,WORK+1 length+1 in Y
;  It returns with EQ set if it can't find the thing, else with
;  IACCL,IACCM pointing to the data item and NEQ.
;  Note that the data is stored ADDRL,ADDRH,"R","E","D",0
LOOKUP STY WORK+2
 LDYIM 1
 LDAIY WORK
 ASLA
 TAY
LOOKMN LDAAY VARPTR-&7F
 BEQ LOOKFX
 STA IACCM
 LDAAY VARPTR-&80
 BRA LOOPLC
LOOPLB LDYIM 1
 LDAIY IACCL
 BEQ LOOKFX
 TAY
 LDAI IACCL
 STY IACCM
LOOPLC STA IACCL
 LDYIM 2
 LDAIY IACCL
 BNE LOOPSA
 CPY WORK+2
 BNE LOOPLB
 BRA LOOPTA
LOOPRA LDAIY IACCL
 BEQ LOOPLB
LOOPSA CMPIY WORK
 BNE LOOPLB
 INY
 CPY WORK+2
 BNE LOOPRA
 LDAIY IACCL
 BNE LOOPLB
LOOPTA TYA
 ADC IACCL
 STA IACCL
 BCC LOOKFX ;NEQ if taken because adding Y and C=1
 INC IACCM ;this is what sets NEQ (!)
LOOKFX RTS
FNDLNO CLR WORK+6 ;find line number in iacc
 LDA TXTP
 STA WORK+7
SIGHT LDYIM 1
 LDAIY WORK+6
 CMP IACCM
 BCS LOOK
LOOKR LDYIM 3
 LDAIY WORK+6
 ADC WORK+6
 STA WORK+6
 BCC SIGHT
 INC WORK+7
 BRA SIGHT
LOOK BNE PAST
 INY ;Y was 1
 LDAIY WORK+6
 CMP IACCL
 BCC LOOKR
 ASSERT :MSB: SIGHT = :MSB: .
 BNE PAST
 RTS ; carry set if found
PAST LDYIM 2
 CLC
 RTS
DIVOP JSR INTEGY ;divide with remainder
 LDA IACCH
 PHA
 JSR ABSCOM
 JSR PHPOW
 STX TYPE
 JSR INTEGY
 PLA
 STA WORK+1
 EOR IACCH
 STA WORK
 JSR ABSCOM
 LDXIM WORK+2
 JSR POPX
 CLR WORK+6
 CLR WORK+7
 CLR WORK+8
 CLR WORK+9
 LDA IACCH
 ORA IACCL
 ORA IACCM
 ORA IACCN
 BEQ ZDIVOR
 LDYIM &20
DIVJUS DEY
 BEQ DIVRET
 ASL WORK+2
 ROL WORK+3
 ROL WORK+4
 ROL WORK+5
 BPL DIVJUS
DIVER ROL WORK+2
 ROL WORK+3
 ROL WORK+4
 ROL WORK+5
 ROL WORK+6
 ROL WORK+7
 ROL WORK+8
 ROL WORK+9
 SEC
 LDA WORK+6
 SBC IACCL
 PHA
 LDA WORK+7
 SBC IACCM
 PHA
 LDA WORK+8
 SBC IACCN
 TAX
 LDA WORK+9
 SBC IACCH
 BCC NOSUB
 STA WORK+9
 STX WORK+8
 PLA
 STA WORK+7
 PLA
 STA WORK+6
 BCS NOSUB+2
NOSUB PLA
 PLA
 DEY
 BNE DIVER
 ASSERT :MSB: DIVER = :MSB: .
DIVRET RTS
ZDIVOR BRK
 = &12
 = "Division by zero"
 BRK
IFLT CLR FACCMG
 CLR FACCXH
 LDA IACCH;+4 possible entry point
 STA FACCS
 BPL IFLTA
 JSR COMPNO
 LDA IACCH
IFLTA BNE IFLTAC
 CLR FACCMD
 LDA IACCN
 BNE IFLTAD
 CLR FACCMC
 LDA IACCM
 BNE IFLTAE
 CLR FACCMB
 LDA IACCL
 BRA FLTAA
IFLTAE LDY IACCL
 STY FACCMB
 LDYIM &90
 BRA FLTAA+2
IFLTAD LDY IACCM
 STY FACCMB
 LDY IACCL
 STY FACCMC
 LDYIM &98
 BRA FLTAA+2
IFLTAC LDY IACCN
 STY FACCMB
 LDY IACCM
 STY FACCMC
 LDY IACCL
 STY FACCMD
 LDYIM &A0
 BRA FLTAA+2
FNRMZ CLR FACCS
 CLR FACCX
 CLR FACCXH
 CLR FACCMA
FNRMX RTS
;   FLTACC FLOATS 8 BIT ACC
FLTACC JSR FCLR
 TAY
 BPL FLTAA ;>=0
 STA FACCS ;SET SIGN IN ACC
 EORIM &FF
 INA
FLTAA LDYIM &88
 ORAIM 0
 BMI FNRMX2
 BEQ FNRMZ
FNRMB2 DEY
 ASL FACCMD
 ROL FACCMC
 ROL FACCMB
 ROLA
 BPL FNRMB2
 ASSERT :MSB: FNRMB2 = :MSB: .
FNRMX2 STA FACCMA
 STY FACCX
 RTS
;   FNRM NORMALIZES THE AC USING 16 BIT EXPONENT, SO
;   NO WORRY ABOUT EXPONENT OVERFLOW
FNRM LDA FACCMA ;+2 and +4 also entry points
 BMI FNRMX
 BNE FNRMAZ
 ORA FACCMB
 ORA FACCMC
 ORA FACCMD
 ORA FACCMG
 BEQ FNRMZ
 LDA FACCX
FNRMA LDY FACCMB
 STY FACCMA
 LDY FACCMC
 STY FACCMB
 LDY FACCMD
 STY FACCMC
 LDY FACCMG
 STY FACCMD
 CLR FACCMG
 SEC
 SBCIM &08 ;MOVED BY A BYTE
 BCS FNRMS ;TRY AGAIN
 DEC FACCXH
FNRMS LDY FACCMA
 BEQ FNRMA
 ASSERT :MSB: FNRMA = :MSB: .
 BMI FNRMXA ;FULLY NORMALIZED
 BRA FNRMB-1
FNRMAZ LDA FACCX
 CLC
FNRMB SBCIM 0 ;carry clear from ROL
 BCS FNRMC
 DEC FACCXH
FNRMC ASL FACCMG
 ROL FACCMD
 ROL FACCMC
 ROL FACCMB
 ROL FACCMA
 BPL FNRMB
 ASSERT :MSB: FNRMB = :MSB: .
FNRMXA STA FACCX
 RTS
SFIX LDA FACCX
 BPL FFIXQ+3 ;starts with <1
 LDY FACCMA
 BEQ FFIXYJ ;except for 0
SFIXG LSR FACCMA
 ROR FACCMB
 ROR FACCMC
 ROR FACCMD
 INA
 BEQ FFIXV
SFIXB CMPIM &A0
 BCS FFIXC ;DONE, OR OVERSHOT
 CMPIM &99
 BCS SFIXG
 ADCIM &08
 LDY FACCMC
 STY FACCMD
 LDY FACCMB
 STY FACCMC
 LDY FACCMA
 STY FACCMB
 CLR FACCMA
 BRA SFIXB
 ASSERT :MSB: SFIXG = :MSB: .
;FFIX leaves faccma-faccmd as a 32 bit integer. Truncates towards zero.
;After a call to ffix, ffrac sets acc to remaining fractional part.
;FFIXA shifts acc right until exponent is $A0.
;Bits shifted out of the bottom of A go into wrk.
FFIXQ JSR FTOW
 JMP FCLR
FFIX LDA FACCX
 BPL FFIXQ ;starts with <1
 JSR FCLRW
 LDY FACCMA
FFIXYJ BEQ FFIXY ;Always shift at least once except for 0
FFIXG LSR FACCMA
 ROR FACCMB
 ROR FACCMC
 ROR FACCMD
 ROR FWRKMA
 ROR FWRKMB
 ROR FWRKMC
 ROR FWRKMD ;ROTATE DOWN INTO WORK.
 INA
 BEQ FFIXV
FFIXB CMPIM &A0
 BCS FFIXC ;DONE, OR OVERSHOT
 CMPIM &99
 BCS FFIXG
 ADCIM &08
 LDY FWRKMC
 STY FWRKMD
 LDY FWRKMB
 STY FWRKMC
 LDY FWRKMA
 STY FWRKMB
 LDY FACCMD
 STY FWRKMA
 LDY FACCMC
 STY FACCMD
 LDY FACCMB
 STY FACCMC
 LDY FACCMA
 STY FACCMB
 CLR FACCMA
 BRA FFIXB
 ASSERT :MSB: FFIXG = :MSB: .
;   HERE I HAVE OVERFLOW
FFIXV JMP FOVR
FFIXC BNE FFIXV
 STA FACCX
FFIXY LDA FACCS
 BPL FFIXZ ;>=0.0 SO DONE NOW
;   FINEG NEGATES 32 BIT INTEGER IN FACCMA-FACCMD
FINEG SEC
 LDYIM 0
 TYA
 SBC FACCMD
 STA FACCMD
 TYA
 SBC FACCMC
 STA FACCMC
 TYA
 SBC FACCMB
 STA FACCMB
 TYA
 SBC FACCMA
 STA FACCMA
FFIXZ RTS
;FFRAC SETS FQUAD TO THE INTEGER PART OF AC, AND AC TO ITS FRACTIONAL PART.
;RETURNS WITH CONDITION CODE SET ZERO IF FRACTION IS ZERO.
;ASSUMES THAT ON INPUT FIX(ACC) < 128.
FFRAC LDA FACCX
 BMI FFRACA ;NORMAL CASE
 CLR FQUAD
 JMP FTST ;ABS(AC)<0.5 ON ENTRY
FFRACA JSR FFIX
 LDA FACCMD
 STA FQUAD
 JSR FMWTOA
 LDAIM &80
 STA FACCX
 LDX FACCMA
 BPL FNEARN ;FRACTION PART < 0.5
 EOR FACCS
 STA FACCS ;CHANGE SIGN OF FRACTION PART
 BPL FNEARQ
 INC FQUAD
 BRA FNEARR
FNEARQ DEC FQUAD
FNEARR JSR FINEG ;ACHIEVES FRACT := 1 - FRACT
FNEARN JMP FNRM
FINC INC FACCMD
 BNE FNEARZ
 INC FACCMC
 BNE FNEARZ
 INC FACCMB
 BNE FNEARZ
 INC FACCMA
 BEQ FFIXV ;OVERFLOW
FNEARZ RTS
FRNDAB LDYIM 4
RTOP ROR SEED+4
 LDA SEED+3
 TAX
 RORA
 STA SEED+4
 LDA SEED+2
 STA SEED+3
 LSRA
 EOR SEED+1
 ANDIM &0F
 EOR SEED+1
 RORA
 RORA
 RORA
 RORA
 EOR SEED+4
 STX SEED+4
 LDX SEED+1
 STX SEED+2
 LDX SEED
 STX SEED+1
 STA SEED
 DEY
 BNE RTOP
 ASSERT :MSB: RTOP = :MSB: .
 RTS
FWTOA LDA FWRKS
 STA FACCS
 CLR FACCXH
 LDA FWRKX
 STA FACCX
FMWTOA LDA FWRKMA
 STA FACCMA
 LDA FWRKMB
 STA FACCMB
 LDA FWRKMC
 STA FACCMC
 LDA FWRKMD
 STA FACCMD
 LDA FWRKMG
 STA FACCMG
FADDZ RTS
FADDW1 LDA FACCMA ;SEE IF ADDING TO 0
 BEQ FWTOA ;LOAD WITH W
;   HERE I HAVE A NONTRIVIAL ADD
 SEC
 LDA FACCX
 SBC FWRKX
 BEQ FADDA
 BCC FADDB ;X(ACC)<X(WRK)
 CMPIM &25
 BCS FADDZ ;SHIFT TOO LARGE FOR SIGNIFICANCE
;   Now shift W right
 TAY
 ANDIM &38
 BEQ FADDCA
 SEC
FADDCB LDX FWRKMD
 STX FWRKMG
 LDX FWRKMC
 STX FWRKMD
 LDX FWRKMB
 STX FWRKMC
 LDX FWRKMA
 STX FWRKMB
 CLR FWRKMA
 SBCIM 8
 BNE FADDCB
FADDCA TYA
 ANDIM &07
 BEQ FADDA
FADDC LSR FWRKMA
 ROR FWRKMB
 ROR FWRKMC
 ROR FWRKMD
 ROR FWRKMG
 DEA
 BNE FADDC
 ASSERT :MSB: FADDC = :MSB: .
 BRA FADDA ;ALIGNED
FADDB EORIM &FF
 INA ;AMOUNT TO SHIFT ACC
 CMPIM &25
 BCS FWTOA ;ACC NOT SIGNIFICANT
 LDY FWRKX ;X(RESULT) FROM X(WRK)
 STY FACCX
;   Now shift ACC right
 TAY
 ANDIM &38
 BEQ FADDDA
 SEC
FADDDB LDX FACCMD
 STX FACCMG
 LDX FACCMC
 STX FACCMD
 LDX FACCMB
 STX FACCMC
 LDX FACCMA
 STX FACCMB
 CLR FACCMA
 SBCIM 8
 BNE FADDDB
FADDDA TYA
 ANDIM &07
 BEQ FADDA
FADDD LSR FACCMA
 ROR FACCMB
 ROR FACCMC
 ROR FACCMD
 ROR FACCMG
 DEA
 BNE FADDD
 ASSERT :MSB: FADDD = :MSB: .
;     DROP THROUGH TO FADDA
FADDA LDA FACCS
 EOR FWRKS
 BMI FADDE ;different signs
 CLC ;BOTH SAME SIGN
 JMP FPLWF
FADDE LDA FACCMA
 CMP FWRKMA
 BNE FADDF
 LDA FACCMB
 CMP FWRKMB
 BNE FADDF
 LDA FACCMC
 CMP FWRKMC
 BNE FADDF
 LDA FACCMD
 CMP FWRKMD
 BNE FADDF
 LDA FACCMG
 CMP FWRKMG
 BNE FADDF
 JMP FCLR  ;ACC=WRK IN DIFFERENCE CASE
FADDF BCS FADDG ;ABS ACC>ABS WRK
 LDA FWRKS
 STA FACCS
 SEC
 LDA FWRKMG
 SBC FACCMG
 STA FACCMG
 LDA FWRKMD
 SBC FACCMD
 STA FACCMD
 LDA FWRKMC
 SBC FACCMC
 STA FACCMC
 LDA FWRKMB
 SBC FACCMB
 STA FACCMB
 LDA FWRKMA
 SBC FACCMA
 STA FACCMA ;OVERFLOW IMPOSSIBLE
 JMP FNRM+2
FADDG LDA FACCMG ;carry set at faddf
 SBC FWRKMG
 STA FACCMG
 LDA FACCMD
 SBC FWRKMD
 STA FACCMD
 LDA FACCMC
 SBC FWRKMC
 STA FACCMC
 LDA FACCMB
 SBC FWRKMB
 STA FACCMB
 LDA FACCMA
 SBC FWRKMA
 STA FACCMA
 JMP FNRM+2

;  lexical tokens and name table

;  The table contains lexical tokens and an action byte
;    6 - polymorphic
;    5 - give up completely
;    4 - constant/list of constants may follow
;    3 - while byte<>wordc skip
;    2 - transfer to l mode
;    1 - transfer to r mode
;    0 - ignore if next character is wordc

;  Every token is recognizable at the start of any word

TAND * &80 ;expression binary operators
TDIV * TAND+1
TEOR * TDIV+1
TMOD * TEOR+1
TOR * TMOD+1

TERROR * TOR+1  ;miscellaneous words
TLINE * TERROR+1
TOFF * TLINE+1
TSTEP * TOFF+1
TSPC * TSTEP+1
TTAB * TSPC+1
TELSE * TTAB+1
TTHEN * TELSE+1

TCONST * TTHEN+1   ;(8D)

TOPENU * TCONST+1
TPTR * TOPENU+1 ;polymorphics as functions
TPAGE * TPTR+1
TTIME * TPAGE+1
TLOMM * TTIME+1
THIMM * TLOMM+1

TABS * THIMM+1 ;expression class of unary operators
TACS * TABS+1
TADC * TACS+1
TASC * TADC+1
TASN * TASC+1
TATN * TASN+1
TBGET * TATN+1
TCOS * TBGET+1
TCOUNT * TCOS+1
TDEG * TCOUNT+1
TERL * TDEG+1
TERR * TERL+1
TEVAL * TERR+1
TEXP * TEVAL+1
TEXT * TEXP+1
TFALSE * TEXT+1
TFN * TFALSE+1
TGET * TFN+1
TINKEY * TGET+1
TINSTR * TINKEY+1
TINT * TINSTR+1
TLEN * TINT+1
TLN * TLEN+1
TLOG * TLN+1
TNOT * TLOG+1
TOPENI * TNOT+1
TOPENO * TOPENI+1
TPI * TOPENO+1
TPOINT * TPI+1
TPOS * TPOINT+1
TRAD * TPOS+1
TRND * TRAD+1
TSGN * TRND+1
TSIN * TSGN+1
TSQR * TSIN+1
TTAN * TSQR+1
TTO * TTAN+1
TTRUE * TTO+1
TUSR * TTRUE+1
TVAL * TUSR+1
TVPOS * TVAL+1
TCHRD * TVPOS+1  ;string expression class of unary operators
TGETD * TCHRD+1
TINKED * TGETD+1
TLEFTD * TINKED+1
TMIDD * TLEFTD+1
TRIGHTD * TMIDD+1
TSTRD * TRIGHTD+1
TSTRND * TSTRD+1
TEOF * TSTRND+1

TAUTO * TEOF+1 ;commands
TDELET * TAUTO+1
TLOAD * TDELET+1
TLIST * TLOAD+1
TNEW * TLIST+1
TOLD * TNEW+1
TRENUM * TOLD+1
TSAVE * TRENUM+1
TEDIT * TSAVE+1

TPTR2 * TEDIT+1 ;polymorphics again
TPAGE2 * TPTR2+1
TTIME2 * TPAGE2+1
TLOMM2 * TTIME2+1
THIMM2 * TLOMM2+1

TBEEP * THIMM2+1 ;statements
TBPUT * TBEEP+1
TCALL * TBPUT+1
TCHAIN * TCALL+1
TCLEAR * TCHAIN+1
TCLOSE * TCLEAR+1
TCLG * TCLOSE+1
TCLS * TCLG+1
TDATA * TCLS+1
TDEF * TDATA+1
TDIM * TDEF+1
TDRAW * TDIM+1
TEND * TDRAW+1
TENDPR * TEND+1
TENVEL * TENDPR+1
TFOR * TENVEL+1
TGOSUB * TFOR+1
TGOTO * TGOSUB+1
TGRAPH * TGOTO+1
TIF * TGRAPH+1
TINPUT * TIF+1
TLET * TINPUT+1
TLOCAL * TLET+1
TMODE * TLOCAL+1
TMOVE * TMODE+1
TNEXT * TMOVE+1
TON * TNEXT+1
TVDU * TON+1
TPLOT * TVDU+1
TPRINT * TPLOT+1
TPROC * TPRINT+1
TREAD * TPROC+1
TREM * TREAD+1
TREPEAT * TREM+1
TREPORT * TREPEAT+1
TRESTOR * TREPORT+1
TRETURN * TRESTOR+1
TRUN * TRETURN+1
TSTOP * TRUN+1
TTEXT * TSTOP+1
TTRACE * TTEXT+1
TUNTIL * TTRACE+1
TWIDTH * TUNTIL+1
TOSCL * TWIDTH+1 ;this must be <=&FF (!)

TOKENS = "AND"   ;this table MUST be alphabetic in first char
 = TAND,0
 = "ABS"
 = TABS,0
 = "ACS"
 = TACS,0
 = "ADVAL"
 = TADC,0
 = "ASC"
 = TASC,0
 = "ASN"
 = TASN,0
 = "ATN"
 = TATN,0
 = "AUTO"
 = TAUTO,&10
 = "BGET"
 = TBGET,1
 = "BPUT"
 = TBPUT,3
 = "COLOUR"
 = TTEXT,2
 = "CALL"
 = TCALL,2
 = "CHAIN"
 = TCHAIN,2
 = "CHR$"
 = TCHRD,0
 = "CLEAR"
 = TCLEAR,1
 = "CLOSE"
 = TCLOSE,3
 = "CLG"
 = TCLG,1
 = "CLS"
 = TCLS,1
 = "COS"
 = TCOS,0
 = "COUNT"
 = TCOUNT,1
 = "COLOR"  ;for the Yanks
 = TTEXT,2
 = "DATA"
 = TDATA,&20
 = "DEG"
 = TDEG,0
 = "DEF"
 = TDEF,0
 = "DELETE"
 = TDELET,&10
 = "DIV"
 = TDIV,0
 = "DIM"
 = TDIM,2
 = "DRAW"
 = TDRAW,2
 = "ENDPROC"
 = TENDPR,1
 = "END"
 = TEND,1
 = "ENVELOPE"
 = TENVEL,2
 = "ELSE"
 = TELSE,&14
 = "EVAL"
 = TEVAL,0
 = "ERL"
 = TERL,1
 = "ERROR"
 = TERROR,4
 = "EOF"
 = TEOF,1
 = "EOR"
 = TEOR,0
 = "ERR"
 = TERR,1
 = "EXP"
 = TEXP,0
 = "EXT"
 = TEXT,1
 = "EDIT"
 = TEDIT,&10
 = "FOR"
 = TFOR,2
 = "FALSE"
 = TFALSE,1
 = "FN"
 = TFN,8
 = "GOTO"
 = TGOTO,&12
 = "GET$"
 = TGETD,0
 = "GET"
 = TGET,0
 = "GOSUB"
 = TGOSUB,&12
 = "GCOL"
 = TGRAPH,2
 = "HIMEM"
 = THIMM,&43
 = "INPUT"
 = TINPUT,2
 = "IF"
 = TIF,2
 = "INKEY$"
 = TINKED,0
 = "INKEY"
 = TINKEY,0
 = "INT"
 = TINT,0
 = "INSTR("
 = TINSTR,0
 = "LIST"
 = TLiST,&10
 = "LINE"
 = TLINE,0
 = "LOAD"
 = TLOAD,2
 = "LOMEM"
 = TLOMM,&43
 = "LOCAL"
 = TLOCAL,2
 = "LEFT$("
 = TLEFTD,0
 = "LEN"
 = TLEN,0
 = "LET"
 = TLET,4
 = "LOG"
 = TLOG,0
 = "LN"
 = TLN,0
 = "MID$("
 = TMIDD,0
 = "MODE"
 = TMODE,2
 = "MOD"
 = TMOD,0
 = "MOVE"
 = TMOVE,2
 = "NEXT"
 = TNEXT,2
 = "NEW"
 = TNEW,1
 = "NOT"
 = TNOT,0
 = "OLD"
 = TOLD,1
 = "ON"
 = TON,2
 = "OFF"
 = TOFF,0
 = "OR"
 = TOR,0
 = "OPENIN"
 = TOPENU,0
 = "OPENOUT"
 = TOPENO,0
 = "OPENUP"
 = TOPENI,0
 = "OSCLI"
 = TOSCL,2
 = "PRINT"
 = TPRINT,2
 = "PAGE"
 = TPAGE,&43
 = "PTR"
 = TPTR,&43
 = "PI"
 = TPI,1
 = "PLOT"
 = TPLOT,2
 = "POINT("
 = TPOINT,0
 = "PROC"
 = TPROC,&0A
 = "POS"
 = TPOS,1
 = "RETURN"
 = TRETURN,1
 = "REPEAT"
 = TREPEAT,0
 = "REPORT"
 = TREPORT,1
 = "READ"
 = TREAD,2
 = "REM"
 = TREM,&20
 = "RUN"
 = TRUN,1
 = "RAD"
 = TRAD,0
 = "RESTORE"
 = TRESTORE,&12
 = "RIGHT$("
 = TRIGHTD,0
 = "RND"
 = TRND,1
 = "RENUMBER"
 = TRENUM,&10
 = "STEP"
 = TSTEP,0
 = "SAVE"
 = TSAVE,2
 = "SGN"
 = TSGN,0
 = "SIN"
 = TSIN,0
 = "SQR"
 = TSQR,0
 = "SPC"
 = TSPC,0
 = "STR$"
 = TSTRD,0
 = "STRING$("
 = TSTRND,0
 = "SOUND"
 = TBEEP,2
 = "STOP"
 = TSTOP,1
 = "TAN"
 = TTAN,0
 = "THEN"
 = TTHEN,&14
 = "TO"
 = TTO,0
 = "TAB("
 = TTAB,0
 = "TRACE"
 = TTRACE,&12
 = "TIME"
 = TTIME,&43
 = "TRUE"
 = TTRUE,1
 = "UNTIL"
 = TUNTIL,2
 = "USR"
 = TUSR,0
 = "VDU"
 = TVDU,2
 = "VAL"
 = TVAL,0
 = "VPOS"
 = TVPOS,1
 = "WIDTH"
 = TWIDTH,2
 = "PAGE"  ;dratted polymorphics again
 = TPAGE2,0
 = "PTR"
 = TPTR2,0
 = "TIME"
 = TTIME2,0
 = "LOMEM"
 = TLOMM2,0
 = "HIMEM"
 = THIMM2,0
 = "Missing "
 = &8D,0
 LNK CBAS02
